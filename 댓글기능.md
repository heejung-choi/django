# 댓글 기능

## article

| ID   |     title     |
| ---- | :-----------: |
| 1    |  안녕하세요   |
| 2    |  반갑습니다.  |
| 3    | 오늘은 월요일 |
|      |               |

 ## comment

| ID   | content | fk   |
| ---- | ------- | ---- |
| 1    | 하이    | 100  |
| 2    | hello   |      |

| ID   | Article | comment |
| ---- | ------- | ------- |
| 1    | 1       | 2       |
| 2    | 2       | 100     |
|      |         |         |

관계설정을 위해 하나의 테이블을 만들어서 연결시켜 준다.

관계라는 것은 단방향이다.



## models.py

```python
from django.db import models

# Create your models here.
class Article(models.Model):
    title = models.CharField(max_length=20)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    # commant_set = 
    
class comment(models.Model):
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    # article_id
```

## bash

```bash
$ python manage.py makemigrations
$ python manage.py migrate
python manage.py shell_plus
```

```python
4. In [1]: Article.objects.all()
   Out[1]: <QuerySet []>

   In [2]: Article.objects.create(title="hello", content="hihi")
   Out[2]: <Article: Article object (1)>

   In [3]: Article.objects.create(title="hello", content="hihi")
   Out[3]: <Article: Article object (2)>

   In [4]: Article.objects.create(title="hello", content="hihi")
   Out[4]: <Article: Article object (3)>

   In [5]: Article.objects.create(title="hello", content="hihi")
   Out[5]: <Article: Article object (4)>

   In [6]: Comment.objects.create(content="lol")

In [8]: a = Article.objects.get(pk=1)

In [9]: a
Out[9]: <Article: Article object (1)>

In [10]: a.title
Out[10]: 'hello'

In [11]: a.content
Out[11]: 'hihi'

In [12]: Comment.objects.create(content="123", article=a)
Out[12]: <Comment: Comment object (1)>

 c = Comment.objects.get(pk=1)

In [14]: c
Out[14]: <Comment: Comment object (1)>

In [15]: c.content
Out[15]: '123'

In [16]: c.created_at
Out[16]: datetime.datetime(2020, 6, 22, 1, 14, 1, 772077, tzinfo=<UTC>)

In [17]: c.article
Out[17]: <Article: Article object (1)>

In [18]: c.article.title
Out[18]: 'hello'

In [19]: c.article_id   : 이게 우리가 생각하는 fk 개념과 상응하는 것. 



In [1]: a = Article.objects.first()  : 첫번째 요소

In [2]: c = Comment.objects.first() :첫번째 요소

In [4]: a.comment_set
Out[4]: <django.db.models.fields.related_descriptors.create_reverse_many_to_one_manager.<locals>.RelatedManager at 0x1f2c6a35388>

In [5]: a.comment_set.all()
Out[5]: <QuerySet [<Comment: Comment object (1)>]>  :쿼리셋 (데이터가 여러개 묶여서 나올때 )

- comment_set 이란 ?  1:N / 하나의 게시물에 여러개 댓글이 달린다! 여러개 댓글이 하나의 게시물에 **속해 있다** ( 게시물 없이 댓글이 돌아다닐 수가 없다 . )

------> 속해있는 친구 한 테 Foriengn Key 줄 것 !  (여기서는 comment가 속해 있으니까.  comment에 fk 줌)

​```
article = models.ForeignKey(Article, on_delete=models.CASCADE)
​```

            포괄 하고 있는 친구 한테는 XXX_set이 자동으로 생성 될 것 ! 

exit()
```



<img width="351" alt="캡처" src="https://user-images.githubusercontent.com/58652391/85240442-29939d00-b473-11ea-9d1d-53b6848b6fee.PNG">

### 

## detail.html

```html

  <form action="{% url 'articles:comment_create' article.pk %}" method="POST">
  {% csrf_token %}
  <input type="text" name="content">
  <button class="btn btn-primary">작성</button>
  </form>
{% endblock %}
```

## urls.py

```python
path('<int:pk>/comments/create', views.comment_create, name='comment_create')
    # article/3/comments/create
```



## views.py

```python
def comment_create(request, pk):
    article = Article.objects.get(pk=pk) # 오른쪽의 pk가 request옆의 pk다
    content = request.POST.get('content')

    Comment.objects.create(article=article, content=content)
    # = 뒤에 있는 변수가 위에 선언한 변수
    return redirect('articles:detail', pk)
```

```

action="/articles/1/comments/create"
```



## admin.py

```
admin.site.register(Comment)
```

## bash

```bash
$ python manage.py createsuperuser
$ python manage.py runserver
```



## 댓글 출력 부분 작성

## detail.html

```python

{% block content %}
  <h1>DETAIL</h1>
  <h00000000002>{{ article.pk }} 번 글</h2>
  <hr>
  <p>제목 : {{ article.title }}</p>
  <p>내용 : {{ article.content }}</p>
  <p>작성 시각 : {{ article.created_at }}</p>
  <p>수정 시각 : {{ article.updated_at }}</p>
  <hr>
  <a href="{% url 'articles:update' article.pk %}" class="btn btn-success">update</a>
  <form action="{% url 'articles:delete' article.pk %}" method="POST" class="d-inline">
    {% csrf_token %}
    <button class="btn btn-danger">delete</button>
  </form><br>
  <a href="{% url 'articles:index' %}">back</a>
  <hr>
 
  <form action="{% url 'articles:comment_create' article.pk %}" method="POST">
  {% csrf_token %}
  <!--<input type="text" name="content">-->  
  {{ form }}
  <button class="btn btn-primary">작성</button>
  </form>

  <hr>
  <!--{{ article.comment_set.all }}
  <QuerySet [<Comment: Comment object (1)>, <Comment: Comment object (2)>, <Comment: Comment object (3)>]>
 -->
  {% for comment in article.comment_set.all%}
    <p>{{ comment.content }}</p>
    <form action="{% url 'articles:comment_delete' article.pk comment.pk %}" method="POST">
    {% csrf_token %}
    <button>삭제</button>
    </form>     
  {% endfor %}  
  <!--html에서는 ()을 빼줘야 하기 때문에 all 뒤에 ()를 빼줬다.-->
{% endblock %}

```



## urls.py

```python
path('<int:article_pk>/comments/<int:comment_pk>/delete', views.comment_delete, name='comment_delete'),
```



## forms.py

```
class CommentForm(forms.ModelForm):

    class Meta:
        model = Comment
        fields = ['content',]
        # 
        #tuple -> ()
        # list -> []
        #fields = '__all__'
        # exclude = 

```



                   ## view.py

```
@require_POST
def comment_create(request, pk):
    # if request.method == 'POST':를 해도 되지만 어차피 여기에는 post 방식만 되기 때문에
    # @require_POST을 해준다.
    article = Article.objects.get(pk=pk) # 오른쪽의 pk가 request옆의 pk다
    #content = request.POST.get('content')
    #Comment.objects.create(article=article, content=content)
    # = 뒤에 있는 변수가 위에 선언한 변수
    form = CommentForm(request.POST)
    if form.is_valid():
        comment = form.save(commit=False)
        comment.article = article
        comment.save()        
        print(comment)
        #  print(comment) -> Comment object (None) 이라고 나온다.
        # save를 하기 전에 상태가 있었는데 , aricle object non이라는 상태이다.
        # commit=False가 해당 역할을 해준다.
        # 어떤 article에 속할지..?

    
    return redirect('articles:detail', pk)                                                         

def comment_delete(request, article_pk, comment_pk):
    comment = Comment.objects.get(pk=comment_pk)
    comment.delete()
    return redirect('articles:detail', article_pk) 
```

