# 20200616 DJANGO

# CREATE

```
# 1
article = Article()
article.title = 'first'
article.content = 'django!'
article.save()
# 파이썬의 클래스

# 2
article = Article(title='second', content='django!!')
article.save()

# 3 - 인스턴스 생성하지 않음!! ->> 내부적으로 save 해줌
Article.objects.create(title='third', content='django!!!')
# 인스턴스를 만들지 않아도 되는데 .create를 해줬기 때문이다.
```

# POST

- 사용자는 DJANGO에게 ***html 파일 줘!(GET)***가 아니라 ***~한 레코드(글)을 생성해줘!(POST)***이기 때문에 http method POST를 사용해야 한다.
- 데이터는 URL에 직접 노출되어서는 안된다.(우리가 URL에 직접 접근하는 방식은 모두 GET 요청)/ query의 형태를 통해 DB구조(schema)를 유추할 수 있고 이는 보안적인 측면에서 매우 취약하다.
- DB를 조작하는 친구는 GET이 아닌 POST! 왜? 중요한 요청이기 때문에 최소한의 신원 확인 필요!



# GET 방식 일때 view.py

```django
def create(request):
    # 1. new에서 보낸 데이터 받기
    title = request.GET.get('title')
    content = request.GET.get('content')

    # 2. db에 저장
    # article = Article()
    # article.title = title
    # # 오른쪽이 new에서 받은 데이터
    # article.content = content
    # article.save()

    article = Article(title=title, content=content)
    #데이터가 유효한지 검사
    #인자로 들어갈 때에는 =에 공백을 넣지 않는다.
    article.save()

    #Article.objects.create(title=title, content=content)

    return render(request, 'articles/index.html')
```



# GET 방식 일때 new.html

```django
{% extends 'base.html' %}

{% block content %}
<h1>NEW</h1>
<form action="{% url 'articles:create' %}" method="GET">
<input type="text" name="title"><br>
<textarea name="content"></textarea>
<button class="btn btn-primary">작성</button>
<input type="submit">
</form>
{% endblock %}
```



- post로 바꿨더니 오류가 난다.

- settings.py

- ```django
  MIDDLEWARE = [
      'django.middleware.security.SecurityMiddleware',
      'django.contrib.sessions.middleware.SessionMiddleware',
      'django.middleware.common.CommonMiddleware',
      'django.middleware.csrf.CsrfViewMiddleware',
      'django.contrib.auth.middleware.AuthenticationMiddleware',
      'django.contrib.messages.middleware.MessageMiddleware',
      'django.middleware.clickjacking.XFrameOptionsMiddleware',
  ]
  ```

- csrf 검사를 middleware에서 수행하기 때문에 오류가 나는 것이다.



# 	post 방식 일때 view.py

```django
from django.shortcuts import render
from .models import Article

# Create your views here.
def index(request):
    articles = Article.objects.all()
    context = {
        'articles': articles,
    }
    return render(request, 'articles/index.html', context)

def new(request):
    return render(request, 'articles/new.html')

def create(request):
    # 1. new에서 보낸 데이터 받기
    title = request.POST.get('title')
    content = request.POST.get('content')

    # 2. db에 저장
    # article = Article()
    # article.title = title
    # # 오른쪽이 new에서 받은 데이터
    # article.content = content
    # article.save()

    article = Article(title=title, content=content)
    #데이터가 유효한지 검사
    #인자로 들어갈 때에는 =에 공백을 넣지 않는다.
    article.save()

    #Article.objects.create(title=title, content=content)

    return render(request, 'articles/index.html')
```

# post 방식일 때 new.html

```django
{% extends 'base.html' %}

{% block content %}
<h1>NEW</h1>
<form action="{% url 'articles:create' %}" method="POST">
{% csrf_token %}
<!--csrf 속성을 줌으로써 간단하게 보안유지를 할 수 있다.-->
<input type="text" name="title"><br>
<textarea name="content"></textarea>
<button class="btn btn-primary">작성</button>
<input type="submit">
</form>
{% endblock %}
```



# redirect

새로운 url로 요청을 보내야 할 때 사용 

```django
return redirect('articles:index')
```

